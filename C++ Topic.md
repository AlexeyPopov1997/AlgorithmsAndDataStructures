# Спровочник по C++

## Содержание
### 1. [Статические переменные](#Статические-переменные)
### 1. [Указатели](#Указатели)
### 2. [Передача параметров в функцию](#Передача-параметров-в-функцию)
### 3. [Статические методы класса](#Статические-методы-класса)
### 4. [Шаблоны функций](#Шаблоны-функций)


### Статические переменные
Использование ключевого слова `static` с локальными переменными изменяет их свойство продолжительности жизни с автоматического на статическое (или «фиксированное»). **Статическая переменная** (или **«переменная со статической продолжительностью жизни»**) сохраняет свое значение даже после выхода из блока, в котором она определена. То есть она создается (и инициализируется) только один раз, а затем сохраняется на протяжении выполнения всей программы.

Одним из наиболее распространенных применений является генерация уникальных идентификаторов. При работе с большим количеством одинаковых объектов внутри программы часто бывает полезно присвоить каждому объекту отдельный уникальный идентификационный номер. Это легко осуществить, используя одну статическую локальную переменную:

```c++
int generateID()
{
    static int s_itemID = 0;
    return s_itemID++;
}
```

Статические переменные имеют некоторые преимущества глобальных переменных (они не уничтожаются до завершения программы), сохраняя при этом локальную область видимости. Таким образом, они намного безопаснее для использования, нежели глобальные переменные.

#### Используемые материалы:
1) [Урок №51. Статические переменные - ravesli.com](https://ravesli.com/urok-51-staticheskie-peremennye/)


### Указатели
#### Оператор адреса &
**Объект** — это часть памяти, которая может хранить значение (переменная частыный случай объекта). При выполнении инициализации переменной, ей автоматически присваивается свободный адрес памяти, и, любое значение, которое мы присваиваем переменной, сохраняется по этому адресу в памяти.

```c++
int b = 8;
```
При выполнении этого стейтмента процессором, выделяется часть оперативной памяти. Всякий раз, когда программа встречает переменную b в выражении или в стейтменте, она понимает, что для того, чтобы получить значение — ей нужно заглянуть в ячейку памяти под соответствующим номером.

**Оператор адреса &** позволяет узнать, какой адрес памяти присвоен определенной переменной.

#### Оператор разыменования *
Оператор разыменования * позволяет получить значение по указанному адресу:

```c++
#include <iostream>
 
int main()
{
    int a = 7;
    std::cout << a << '\n'; // выводим значение переменной a
    std::cout << &a << '\n'; // выводим адрес переменной a
    std::cout << *&a << '\n'; /// выводим значение ячейки памяти переменной a
 
    return 0;
}
```

#### Указатели
**Указатель** — это переменная, значением которой является адрес ячейки памяти. 

Поскольку указатели содержат только адреса, то при присваивании указателю значения — это значение должно быть адресом. Для получения адреса переменной используется оператор адреса:

```c++
int value = 5;
int *ptr = &value; // инициализируем ptr адресом значения переменной
```

`ptr` содержит адрес значения переменной `value`, и, можно сказать, что `ptr` указывает на это значение.

Следующее не является допустимым:

```c++
int *ptr = 7;
double *dPtr = 0x0012FF7C;
```
Стоит отметить, что оператор адреса `&` не возвращает адрес своего операнда в качестве литерала. Вместо этого он возвращает указатель, содержащий адрес операнда, тип которого получен из аргумента (например, адрес переменной типа `int` передается как адрес указателя на значение типа `int`):

```c++
#include <iostream>
#include <typeinfo>
 
int main()
{
	int x(4);
	std::cout << typeid(&x).name();
 
	return 0;
}
```
Как только у нас есть указатель, указывающий на что-либо, мы можем его разыменовать, чтобы получить значение, на которое он указывает. Разыменованный указатель — это содержимое ячейки памяти, на которую он указывает.

Указатели в языке C++ по своей природе являются небезопасными, а их неправильное использование — один из лучших способов получить сбой программы.

При разыменовании указателя, программа пытается перейти в ячейку памяти, которая хранится в указателе и извлечь содержимое этой ячейки. По соображениям безопасности современные операционные системы (ОС) запускают программы в песочнице для предотвращения их неправильного взаимодействия с другими программами и для защиты стабильности самой операционной системы. Если программа попытается получить доступ к ячейке памяти, не выделенной для нее операционной системой, то ОС сразу завершит выполнение этой программы.

Следующая программа хорошо иллюстрирует вышесказанное. При запуске вы получите сбой:

```c++
#include <iostream>
 
void foo(int *&p)
{
}
 
int main()
{
    int *p; // создаем неинициализированный указатель (содержимым которого является мусор)
    foo(p); // вводим компилятор в заблуждение, будто бы собираемся присвоить указателю корректное значение
	    
    std::cout << *p; // разыменовываем указатель с мусором
 
    return 0;
}
```

Размер указателя зависит от архитектуры, на которой скомпилирован исполняемый файл: 32-битный исполняемый файл использует 32-битные адреса памяти. Следовательно, указатель на 32-битном устройстве занимает 32 бита (4 байта). С 64-битным исполняемым файлом указатель будет занимать 64 бита (8 байт). И это вне зависимости от того, на что указывает указатель. Это связано с тем, что указатель — это всего лишь адрес памяти, а количество бит, необходимое для доступа к адресу памяти на определенном устройстве, — всегда постоянное.

**Указатели полезны в следующих случаях:**
1. **Массивы реализованы с помощью указателей.** Указатели могут использоваться для итерации по массиву.
2. **Они являются единственным способом динамического выделения памяти в C++.**
3. **Они могут использоваться для передачи большого количества данных в функцию без копирования этих данных.**
4. **Они могут использоваться для передачи одной функции в качестве параметра другой функции.**
5. **Они используются для достижения полиморфизма при работе с наследованием.**
6. **Они могут использоваться для представления одной структуры/класса в другой структуре/классе, формируя, таким образом, целые цепочки.**

#### Используемые материалы:
1) [Урок №80. Указатели - ravesli.com](https://ravesli.com/urok-80-ukazateli-vvedenie/)


### Передача параметров в функцию
#### Передача параметров в функцию по значению

По умолчанию, аргументы в C++ передаются по значению. Когда аргумент передается по значению, то его значение копируется в параметр функции.
Поскольку в функцию передается копия аргумента, то исходное значение не может быть изменено функцией.

Параметры функции, переданные по значению, также могут быть `const`. Тогда уже будет 100% гарантия того, что функция не изменит значение параметра.

**Плюсы и минусы передачи по значению**
**Плюсы передачи по значению**:
* Аргументы, переданные по значению, могут быть переменными (например, `x`), литералами (например, `8`), выражениями (например, `x + 2`), структурами, классами или перечислителями (т.е. почти всем, чем угодно);
* Аргументы никогда не изменяются функцией, в которую передаются, что предотвращает возникновение побочных эффектов;

**Минусы передачи по значению**:
* Копирование структур и классов может привести к значительному снижению производительности (особенно, когда функция вызывается много раз);

**Когда использовать передачу по значению**:
* При передаче фундаментальных типов данных и перечислителей, когда предполагается, что функция не должна изменять аргумент.

**Когда не использовать передачу по значению**:
* При передаче массивов, структур и классов.

В большинстве случаев, передача по значению — это наилучший способ передачи аргументов фундаментальных типов данных, когда функция не должна изменять исходные значения. Передача по значению является гибкой и безопасной, а в случае фундаментальных типов данных еще и эффективной.

#### Используемые материалы:
1) [Урок №97. Передача по значению - ravesli.com](https://ravesli.com/urok-97-peredacha-argumentov-po-znacheniyu/)

#### Передача параметров в функцию по ссылке
Передача по значению является хорошим вариантом во многих случаях, но она имеет несколько ограничений.

Во-первых, при передаче по значению большой структуры или класса в функцию, создается копия аргумента и уже эта копия передается в параметр функции. В большинстве своем это бесполезная трата ресурсов, которая снижает производительность.

Во-вторых, при передаче аргументов по значению, единственный способ вернуть значение обратно в вызывающий объект — это использовать возвращаемое значение функции. Но иногда случаются ситуации, когда нужно, чтобы функция изменила значение переданного аргумента. Передача по ссылке решает все эти проблемы.

При передаче переменной по ссылке нужно просто объявить параметры функции как ссылки, а не как обычные переменные:

```c++
void func(int &x) // x - это переменная-ссылка
{
    x = x + 1;
}
```

При вызове функции переменная x станет ссылкой на аргумент. Поскольку ссылка на переменную обрабатывается точно так же, как и сама переменная, то любые изменения, внесенные в ссылку, приведут к изменениям исходного значения аргумента! 

Иногда нам может понадобиться, чтобы функция возвращала сразу несколько значений. Однако оператор return позволяет функции иметь только одно возвращаемое значение. Одним из способов возврата сразу нескольких значений является использование ссылок в качестве параметров:

```c++
#include <iostream>
#include <math.h>
 
void getSinCos(double degrees, double &sinOut, double &cosOut)
{
    const double pi = 3.14159265358979323846;
    double radians = degrees * pi / 180.0;
    sinOut = sin(radians);
    cosOut = cos(radians);
}
 
int main()
{
    double sin(0.0);
    double cos(0.0);
 
    getSinCos(30.0, sin, cos);

    return 0;
}
```

Параметры, которые используются только для возврата значений обратно в `caller`, называются **параметрами вывода**. Они дают понять `caller`-у, что значения исходных переменных, переданных в функцию, не столь значительны, так как мы ожидаем, что эти переменные будут перезаписаны.

Хотя этот способ хорош, но он также имеет свои нюансы. 

Во-первых, синтаксис немного непривычен, так как параметры ввода и вывода указываются вместе с вызовом функции. Во-вторых, в `caller`-е не очевидно, что `sin` и `cos` являются параметрами вывода, и они будут изменены функцией. Это, вероятно, самая опасная часть данного способа передачи (так как может привести к ошибкам). Некоторые программисты считают, что это достаточно большая проблема, и не советуют передавать аргументы по ссылке, отдав предпочтение передаче по адресу, не смешивая при этом параметры ввода и вывода.

Лично я не рекомендую смешивать параметры ввода и вывода именно по этой причине, но если вы это делаете, то обязательно добавляйте **комментарии к коду**, описывая, что вы делаете и как это делаете.

Неконстантные ссылки могут ссылаться только на неконстантные **l-values** (например, на неконстантные переменные), поэтому параметр-ссылка не может принять аргумент, который является константным **l-value** или **r-value** (например, литералом или результатом выражения).

Когда аргумент передается по ссылке, то создается ссылка на фактический аргумент (что занимает минимальное количество времени на выполнение), и никакого копирования значений не происходит. Это позволяет передавать большие структуры или классы с минимальной затратой ресурсов.

Однако здесь также могут возникнуть потенциальные проблемы. Ссылки позволяют функции изменять значения аргументов напрямую, что нежелательно, если мы хотим, чтобы аргумент был доступен только для чтения. Когда мы знаем, что функция не должна изменять значение аргумента, но не хотим использовать передачу по значению, то лучшим решением будет использовать **передачу по константной ссылке**.

**Константная ссылка** — это ссылка на переменную, значение которой изменить через эту же ссылку не получится никак. Следовательно, если мы используем константную ссылку в качестве параметра, то получаем 100% гарантию того, что функция не изменит аргумент!

Использование `const` полезно по нескольким причинам:
* Мы получаем гарантию от компилятора, что значения, которые не должны быть изменены — не изменятся;
* Программист, видя `const`, понимает, что функция не изменит значение аргумента. Это может помочь при отладке программы;
* Мы не можем передать константный аргумент в неконстантную ссылку-параметр. Использование константного параметра гарантирует, что мы сможем передавать как неконстантные, так и константные аргументы в функцию;
* Константные ссылки могут принимать любые типы аргументов, включая l-values, константные l-values ​​и r-values.

**Правило: При передаче аргументов по ссылке всегда используйте константные ссылки, если вам не нужно, чтобы функция изменяла значения аргументов.**

**Плюсы и минусы передачи по ссылке**
**Плюсы передачи по ссылке:**
* Ссылки позволяют функции изменять значение аргумента, что иногда полезно. В противном случае, для гарантии того, что функция не изменит значение аргумента, нужно использовать константные ссылки;
* Поскольку при передаче по ссылке копирования аргументов не происходит, то этот способ гораздо эффективнее и быстрее передачи по значению, особенно при работе с большими структурами или классами;
* Ссылки могут использоваться для возврата сразу нескольких значений из функции (через параметры вывода).

**Минусы передачи по ссылке:**
* Трудно определить, является ли параметр, переданный по неконстантной ссылке, параметром ввода, вывода или того и другого одновременно. Разумное использование `const` и суффикса `Out` для внешних переменных решает эту проблему;
* По вызову функции невозможно определить, будет аргумент изменен функцией или нет. Аргумент, переданный по значению или по ссылке, выглядит одинаково. Мы можем определить способ передачи аргумента только просмотрев объявление функции. Это может привести к ситуации, когда программист не сразу поймет, что функция изменяет значение аргумента.

**Когда использовать передачу по ссылке:**
* При передаче структур или классов (используйте const, если нужно только для чтения);
* Когда нужно, чтобы функция изменяла значение аргумента.

**Когда не использовать передачу по ссылке:**
* При передаче фундаментальных типов данных (используйте передачу по значению);
* При передаче обычных массивов (используйте передачу по адресу).

#### Используемые материалы:
1) [Урок №98. Передача по ссылке - ravesli.com](https://ravesli.com/urok-98-peredacha-argumentov-po-ssylke/)

#### Передача параметров в функцию по адресу
**Передача аргументов по адресу** — это передача адреса переменной-аргумента (а не исходной переменной). Поскольку аргумент является адресом, то параметром функции должен быть указатель. Затем функция сможет разыменовать этот указатель для доступа или изменения исходного значения:

```c++
#include <iostream>
 
void boo(int *ptr)
{
    *ptr = 7;
}
 
int main()
{
    int value = 4;
 
    std::cout << "value = " << value << '\n';
    boo(&value);
    std::cout << "value = " << value << '\n';
    return 0;
}
```

 **Фиксированные массивы распадаются в указатели** при передаче в функцию, поэтому их длину нужно передавать в виде отдельного параметра. Перед разыменованием параметров, передаваемых по адресу, не лишним будет проверить — не являются ли они нулевыми указателями. Разыменование нулевого указателя приведет к сбою в программе:

 ```c++
#include <iostream>
 
void printArray(int *array, int length)
{
    if (!array)
        return;
 
    for (int index=0; index < length; ++index)
        std::cout << array[index] << ' ';
}
 
int main()
{
    int array[7] = { 9, 8, 6, 4, 3, 2, 1 };
    printArray(array, 7);
}
```

Когда вы передаете указатель в функцию по адресу, то значение этого указателя (адрес, на который он указывает) копируется из аргумента в параметр функции. Другими словами, он **передается по значению**! Если изменить значение параметра функции, то изменится только копия, исходный указатель-аргумент не будет изменен.

Обратите внимание, хотя сам адрес передается по значению, вы все равно можете разыменовать его для изменения значения исходного аргумента:
1) При передаче аргумента по адресу в переменную-параметр функции копируется адрес из аргумента. В этот момент параметр функции и аргумент указывают на одно и то же значение;
2) Если параметр функции затем разыменовать для изменения исходного значения, то это приведет к изменению значения, на которое указывает аргумент, поскольку параметр функции и аргумент указывают на одно и то же значение;
3) Если параметру функции присвоить другой адрес, то это никак не повлияет на аргумент, поскольку параметр функции является копией, а изменение копии не приводит к изменению оригинала. После изменения адреса параметра функции, параметр функции и аргумент будут указывать на разные значения, поэтому разыменование параметра и дальнейшее его изменение никак не повлияют на значение, на которое указывает аргумент.

Для изменения адреса, на который указывает агрумент, внутри функции нужно передать адрес по ссылке.

**Плюсы и минусы передачи по адресу**
**Плюсы передачи по адресу:**
* Передача по адресу позволяет функции изменить значение аргумента, что иногда полезно. В противном случае, используем const для гарантии того, что функция не изменит аргумент;
* Поскольку копирования аргументов не происходит, то скорость передачи по адресу достаточно высокая, даже если передавать большие **структуры** или классы;
* Мы можем вернуть сразу несколько значений из функции, используя **параметры вывода**.

**Минусы передачи по адресу:**
* Все указатели нужно проверять, не являются ли они нулевыми. Попытка разыменовать нулевой указатель приведет к сбою в программе;
* Поскольку разыменование указателя выполняется медленнее, чем доступ к значению напрямую, то доступ к аргументам, переданным по адресу, выполняется также медленнее, чем доступ к аргументам, переданным по значению.

**Когда использовать передачу по адресу:**
* При передаче обычных массивов (если нет никаких проблем с тем, что массивы распадаются в указатели при передаче).

**Когда не использовать передачу по адресу:**
* При передаче структур или классов (используйте передачу по ссылке);
* При передаче фундаментальных типов данных (используйте передачу по значению).

**Правило: Используйте передачу по ссылке, вместо передачи по адресу, когда это возможно.**

#### Используемые материалы:
1) [Урок №99. Передача по адресу - ravesli.com](https://ravesli.com/urok-99-peredacha-argumentov-po-adresu/)


### Статические переменные-члены класса
Переменные-члены класса можно сделать статическими, используя ключевое слово static. В отличие от обычных переменных-членов, статические переменные-члены являются общими для всех объектов класса. 

 ```c++
#include <iostream>
 
class Anything
{
public:
    static int s_value;
};
 
int Anything::s_value = 3;
 
int main()
{
    Anything first;
    Anything second;
 
    first.s_value = 4;
 
    std::cout << first.s_value << '\n';
    std::cout << second.s_value << '\n';
    return 0;
}
```

Статические члены существуют, даже если объекты класса не созданы! Подобно глобальным переменным, они создаются при запуске программы и уничтожаются, когда программа завершает свое выполнение.

Определение статического члена не подпадает под действия спецификаторов доступа: вы можете определить и инициализировать статическую переменную-член даже если он будет `private` (или `protected`).

Если класс определен в заголовочном файле, то определение статического члена обычно помещается в файл с кодом класса. Если класс определен в файле `.cpp`, то определение статического члена обычно пишется непосредственно под классом. Не пишите определение статического члена класса в заголовочном файле (подобно глобальным переменным). Если этот заголовочный файл подключают больше одного раза, то вы получите несколько определений одного члена, что приведет к ошибке компиляции.

Есть несколько обходных путей определения статических членов внутри тела класса.
Во-первых, если статический член является константным интегральным типом (к которому относятся и `char`, и `bool`) или константным перечислением, то статический член может быть инициализирован внутри тела класса:

 ```c++
class Anything
{
public:
    static const int s_value = 5; // статическую константную переменную типа int можно объявить и инициализировать напрямую
};
```

Поскольку здесь статическая переменная-член является целочисленной константой, то дополнительной строки явного определения вне тела класса уже не требуется.

Во-вторых, начиная с C++11 статические члены `constexpr` любого типа данных, поддерживающие инициализацию `constexpr`, могут быть инициализированы внутри тела класса:
 
 ```c++
#include <array>
 
class Anything
{
public:
    static constexpr double s_value = 3.4;
    static constexpr std::array<int, 3> s_array = { 3, 4, 5 }; // это работает даже с классами, которые поддерживают инициализацию constexpr
};
```

### Статические методы класса
Подобно статическим переменным-членам, статические методы не привязаны к какому-либо одному объекту класса:

 ```c++
class Anything
{
private:
    static int s_value;
public:
    static int getValue() { return s_value; } // статический метод
};
 
int Anything::s_value = 3; // определение статической переменной-члена класса
 
int main()
{
    std::cout << Anything::getValue() << '\n';
}
```

Поскольку статические методы не привязаны к определенному объекту, то их можно вызывать напрямую через имя класса и оператор разрешения области видимости, а также через объекты класса (но это не рекомендуется).

У статических методов есть две интересные особенности.

Во-первых, поскольку статические методы не привязаны к объекту, то они не имеют **скрытого указателя *this**! Здесь есть смысл, так как указатель `*this` всегда указывает на объект, с которым работает метод. Статические методы могут не работать через объект, поэтому и указатель `*this` не нужен.

Во-вторых, статические методы могут напрямую обращаться к другим статическим членам (переменным или функциям), но не могут напрямую обращаться к нестатическим членам. Это связано с тем, что нестатические члены принадлежат объекту класса, а статические методы — нет!

Статические методы можно определять вне тела класса. Это работает так же, как и с обычными методами. Например:

 ```c++
#include <iostream>
 
class IDGenerator
{
private:
    static int s_nextID; // объявление статической переменной-члена
 
public:
     static int getNextID(); // объявление статического метода
};
 
// Определение статической переменной-члена находится вне тела класса. Обратите внимание, мы не используем здесь ключевое слово static.
// Начинаем генерировать ID с 1
int IDGenerator::s_nextID = 1;
 
// Определение статического метода находится вне тела класса. Обратите внимание, мы не используем здесь ключевое слово static
int IDGenerator::getNextID() { return s_nextID++; } 
 
int main()
{
    for (int count=0; count < 4; ++count)
        std::cout << "The next ID is: " << IDGenerator::getNextID() << '\n';
 
    return 0;
}
```

Обратите внимание, поскольку все переменные и функции этого класса являются статическими, то нам не нужно создавать объект этого класса для работы с ним! Статическая переменная-член используется для хранения значения следующего идентификатора, который должен быть ей присвоен, а статический метод — для возврата идентификатора и его увеличения.

C++ не поддерживает статические конструкторы!

#### Используемые материалы:
1) [Урок №125. Статические методы класса - ravesli.com](https://ravesli.com/urok-125-staticheskie-metody-klassa/)


### Шаблоны функций
В языке C++ **шаблоны функций — это функции, которые служат образцом для создания других подобных функций**. Главная идея — создание функций без указания точного типа(ов) некоторых или всех переменных. Для этого мы определяем функцию, указывая тип параметра шаблона, который используется вместо любого типа данных. После того, как мы создали функцию с типом параметра шаблона, мы фактически создали «трафарет функции».

Для соглания шаблонной функции нужно сообщить компилятору две вещи:
* Определение шаблона функции;
* Указание того, что `T` является типом параметра шаблона функции.

 ```c++
template <typename T> // объявление параметра шаблона функции
T max(T a, T b)
{
    return (a > b) ? a : b;
}
```

Для создания типов параметров шаблона используются ключевые слова `typename` и `class`. В базовых случаях использования шаблонов функций разницы между `typename` и `class` нет, поэтому вы можете выбрать любое из двух. Если вы используете ключевое слово `class`, то фактический тип параметров не обязательно должен быть классом (это может быть переменная фундаментального типа данных, указатель или что-то другое).

Поскольку тип аргумента функции, передаваемый в тип `T`, может быть классом, а классы, как правило, не рекомендуется передавать по значению, то лучше сделать параметры и возвращаемое значение нашего шаблона функции константными ссылками, например:

 ```c++
template <typename T>
const T& max(const T& a, const T& b)
{
    return (a > b) ? a : b;
}
```

Использование шаблонов функций аналогично использованию обычных функций.

У шаблонов функций есть несколько недостатков:
* Во-первых, некоторые старые компиляторы могут не поддерживать шаблоны функций или поддерживать, но с ограничениями. Однако сейчас это уже не такая проблема, как раньше;
* Во-вторых, шаблоны функций часто выдают сумасшедшие сообщения об ошибках, которые намного сложнее расшифровать, чем ошибки обычных функций;
* В-третьих, шаблоны функций могут увеличить время компиляции и размер кода, так как один шаблон может быть «реализован» и перекомпилирован в нескольких файлах.

#### Используемые материалы:
1) [Урок №173. Шаблоны функций - ravesli.com](https://ravesli.com/urok-173-shablony-funktsij/)


