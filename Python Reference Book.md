# Спровочник по Python

## Содержание
### 1. [Лямда-функции](#Лямда-функции)
### 2. [Декораторы](#Декораторы)
####    а) [Полезные декораторы](#Полезные-декораторы)
### 3. [Общие структуры данных в Python](#Общие-структуры-данных-в-Python)
####    а) [Словари, ассоциативные массивы и хеш-таблицы](#Словари,-ассоциативные-массивы-и-хеш-таблицы)
####    б) [Массивоподобные структуры данных](#Массивоподобные-структуры-данных)

####    в) [Записи, структуры и объекты переноса данных](#Записи,-структуры-и-объекты-переноса-данных)
####    г) [Множества и мультимножества](#Множества-и-мультимножества)

####    д) [Стеки](#Стеки)
####    е) [Очереди](#Очереди)
####    ж) [Очереди с приоритетом](#Очереди-с-приоритетом)


## Лямда-функции
Ключевое слово `lambda` в Python предоставляет краткую форму для объявления небольших анонимных функций. Лямбда-функции ведут себя точно так же, как обычные функции, объявляемые ключевым словом `def`. Они могут использоваться всякий раз, когда требуются объекты-функции.

Например, ниже показано определение простой лямбда-функции, выполняющей сложение:

 ```python
add = lambda x, y: x + y

add(5, 3) 
 ```

Та же самая функция `add` может быть определена при помощи ключевого слова `def`, но она была бы чуть-чуть многословнее:

 ```python
def add(x, y):
    return x + y

add(5, 3) 
 ```

С помощью лямда-функции можно определить однострочную функцию `add`, а затем немедленно вызвать ее с аргументами `5` и `3`:

 ```python
 (lambda x, y: x + y)(5, 3)
 ```

Основное отличие лямда-функций в том, что перед её использованием не приходится связывать объект-функцию с именем.

Существует еще одно синтаксическое различие между определениями лямбд и обычных функций. Лямбда-функции ограничены одним-единственным выражением. Это означает, что в лямбда-функциях не могут применяться инструкции или аннотации — и даже инструкция `return`.

При исполнении лямбда-функции ее выражение вычисляется и затем результат выражения автоматически возвращается, поэтому всегда существует **неявная** инструкция `return`.

Вот еще одна интересная вещь о лямбдах: как и обычные вложенные функции, лямбды работают также и как **лексические замыкания**.

**Замыкание** - это лишь затейливое название для функции, которая помнит значения из объемлющего лексического контекста, даже когда поток управления программы больше не находится в этом контексте:

 ```python
def make_adder(n):
    return lambda x: x + n

plus_3 = make_adder(3)
plus_5 = make_adder(5)

plus_3(4)
plus_5(4) 
 ```

* **Лямбда-функции — это функции одного-единственного выражения, которые не обязательно привязаны к имени (анонимны).**
* **В лямбда-функциях нельзя использовать обычные инструкции `Python`, и в них всегда содержится неявная инструкция возврата `return`.**
* **Всегда спрашивайте себя: обеспечит ли применение обычной (именованной) функции либо конструкции включения в список большую ясность?**

#### Используемые материалы:
1) Лямбды — это функции одного выражения - Чистый Puthon (Дэн Бейдер)


## Декораторы

**Функции в python являются объектами**, соответственно, их можно возвращать из другой функции или передавать в качестве аргумента. Также следует помнить, что функция в python может быть определена и внутри другой функции.

**Декораторы** — это, по сути, "обёртки", которые дают нам возможность изменить поведение функции, не изменяя её код.

 ```python
def decorator(function_to_decorate):
    # Внутри себя декоратор определяет функцию-"обёртку". Она будет обёрнута вокруг декорируемой,
    # получая возможность исполнять произвольный код до и после неё.
    def the_wrapper_around_the_original_function():
        print("Я - код, который отработает до вызова функции")
        function_to_decorate() # Сама функция
        print("А я - код, срабатывающий после")
        # Вернём эту функцию
        return the_wrapper_around_the_original_function

# Представим теперь, что у нас есть функция, которую мы не планируем больше трогать.
def stand_alone_function():
    print("Я простая одинокая функция, ты ведь не посмеешь меня изменять?")

stand_alone_function()

# Однако, чтобы изменить её поведение, мы можем декорировать её, то есть просто передать декоратору,
# который обернет исходную функцию в любой код, который нам потребуется, и вернёт новую,
# готовую к использованию функцию:
stand_alone_function_decorated = decorator(stand_alone_function)
stand_alone_function_decorated()
```

Для того, чтобы каждый раз, во время вызова `stand_alone_function`, вместо неё вызывалась `stand_alone_function_decorated` нужно перезаписать `stand_alone_function`:

```python
stand_alone_function = decorator(stand_alone_function)
stand_alone_function()
```

Используя синтаксис декораторов, предыдущий пример можно записать следующим образом:

```python
@mdecorator
def another_stand_alone_function():
    print("Оставь меня в покое")

another_stand_alone_function()
```

То есть, **декораторы в python — это просто синтаксический сахар** для конструкций вида:

```python
another_stand_alone_function = decorator(another_stand_alone_function)
```

Можно использовать несколько декораторов для одной функции:

```python
def bread(func):
    def wrapper():
        print()
        func()
        print("<\______/>")
    return wrapper

def ingredients(func): 
    def wrapper():
        print("#помидоры#")
        func()
        print("~салат~")
    return wrapper

def sandwich(food="--ветчина--"):
    print(food)

sandwich = bread(ingredients(sandwich))
sandwich()
```

И используя синтаксис декораторов:

```python
@ingredients
@bread
def sandwich(food="--ветчина--"):
    print(food)

sandwich()
```

### Передача декоратором аргументов в функцию

```python
def a_decorator_passing_arguments(function_to_decorate):
    def a_wrapper_accepting_arguments(arg1, arg2):
        print("Смотри, что я получил:", arg1, arg2)
        function_to_decorate(arg1, arg2)
    return a_wrapper_accepting_arguments

# Теперь, когда мы вызываем функцию, которую возвращает декоратор, мы вызываем её "обёртку",
# передаём ей аргументы и уже в свою очередь она передаёт их декорируемой функции
@a_decorator_passing_arguments
def print_full_name(first_name, last_name):
    print("Меня зовут", first_name, last_name)
    
print_full_name("Vasya", "Pupkin")
```

### Декорирование методов

```python
def a_decorator_passing_arguments(function_to_decorate):
    def a_wrapper_accepting_arguments(arg1, arg2):
        print("Смотри, что я получил:", arg1, arg2)
        function_to_decorate(arg1, arg2)
    return a_wrapper_accepting_arguments

# Теперь, когда мы вызываем функцию, которую возвращает декоратор, мы вызываем её "обёртку",
# передаём ей аргументы и уже в свою очередь она передаёт их декорируемой функции
@a_decorator_passing_arguments
def print_full_name(first_name, last_name):
    print("Меня зовут", first_name, last_name)
    
print_full_name("Vasya", "Pupkin")
```

### Декорирование методов

Один из важных фактов, которые следует понимать, заключается в том, что функции и методы в `Python` — это практически одно и то же, за исключением того, что методы всегда ожидают первым параметром ссылку на сам объект (`self`). Это значит, что мы можем создавать декораторы для методов точно так же, как и для функций, просто не забывая про `self`.

```python
def method_friendly_decorator(method_to_decorate):
    def wrapper(self, lie):
        lie -= 3
        return method_to_decorate(self, lie)
    return wrapper

class Lucy:
    def __init__(self):
        self.age = 32
        
        @method_friendly_decorator
        def sayYourAge(self, lie):
            print("Мне {} лет, а ты бы сколько дал?".format(self.age + lie))

l = Lucy()
l.sayYourAge(-3)
```

Конечно, если мы создаём максимально общий декоратор и хотим, чтобы его можно было применить к любой функции или методу, то можно воспользоваться распаковкой аргументов:

```python
def a_decorator_passing_arbitrary_arguments(function_to_decorate):
    # Данная "обёртка" принимает любые аргументы
    def a_wrapper_accepting_arbitrary_arguments(*args, **kwargs):
        print("Передали ли мне что-нибудь?:")
        print(args)
        print(kwargs)
        function_to_decorate(*args, **kwargs)
    return a_wrapper_accepting_arbitrary_arguments

@a_decorator_passing_arbitrary_arguments
def function_with_no_argument():
    print("Python is cool, no argument here.")

function_with_no_argument()

@a_decorator_passing_arbitrary_arguments
def function_with_arguments(a, b, c):
    print(a, b, c)

function_with_arguments(1, 2, 3)

@a_decorator_passing_arbitrary_arguments
def function_with_named_arguments(a, b, c, platypus="Почему нет?"):
    print("Любят ли {}, {} и {} утконосов? {}".format(a, b, c, platypus))

function_with_named_arguments("Билл", "Линус", "Стив", platypus="Определенно!")

class Mary(object):
    def __init__(self):
        self.age = 31
        
        @a_decorator_passing_arbitrary_arguments
        def sayYourAge(self, lie=-3): # Теперь мы можем указать значение по умолчанию
            print("Мне {} лет, а ты бы сколько дал?".format(self.age + lie))

m = Mary()
m.sayYourAge()
```

### Декораторы с аргументами

А теперь попробуем написать декоратор, принимающий аргументы:

```python
def decorator_maker():
    print("Я создаю декораторы! Я буду вызван только раз: когда ты попросишь меня создать декоратор.")
    def my_decorator(func):
        print("Я - декоратор! Я буду вызван только раз: в момент декорирования функции.")
        def wrapped():
            print ("Я - обёртка вокруг декорируемой функции.\n"
                   "Я буду вызвана каждый раз, когда ты вызываешь декорируемую функцию.\n"
                   "Я возвращаю результат работы декорируемой функции.")
            return func()
        print("Я возвращаю обёрнутую функцию.")
        return wrapped
    print("Я возвращаю декоратор.")
    return my_decorator

# Давайте теперь создадим декоратор. Это всего лишь ещё один вызов функции
new_decorator = decorator_maker()

 Теперь декорируем функцию
def decorated_function():
    print("Я - декорируемая функция.")

decorated_function = new_decorator(decorated_function)

# Теперь наконец вызовем функцию:
decorated_function()
```

Теперь перепишем данный код с помощью декораторов:

```python
def decorator_maker_with_arguments(decorator_arg1, decorator_arg2):
    print("Я создаю декораторы! И я получил следующие аргументы:", decorator_arg1, decorator_arg2)
    
    def my_decorator(func):
        print("Я - декоратор. И ты всё же смог передать мне эти аргументы:", decorator_arg1, decorator_arg2)
        
        # Не перепутайте аргументы декораторов с аргументами функций!
        def wrapped(function_arg1, function_arg2):
            print ("Я - обёртка вокруг декорируемой функции.\n"
                   "И я имею доступ ко всем аргументам\n"
                   "\t- и декоратора: {0} {1}\n"
                   "\t- и функции: {2} {3}\n"
                   "Теперь я могу передать нужные аргументы дальше"
                   .format(decorator_arg1, decorator_arg2, function_arg1, function_arg2))
            return func(function_arg1, function_arg2)
        return wrapped
    return my_decorator

@decorator_maker_with_arguments("Леонард", "Шелдон")
def decorated_function_with_arguments(function_arg1, function_arg2):
    print ("Я - декорируемая функция и я знаю только о своих аргументах: {0}"
           " {1}".format(function_arg1, function_arg2))

decorated_function_with_arguments("Раджеш", "Говард")
```

Таким образом, мы можем передавать декоратору любые аргументы, как обычной функции. Мы можем использовать и распаковку через `*args` и `**kwargs` в случае необходимости.

### Некоторые особенности работы с декораторами

* Декораторы несколько замедляют вызов функции, не забывайте об этом.
* Вы не можете "раздекорировать" функцию. Безусловно, существуют трюки, позволяющие создать декоратор, который можно отсоединить от функции, но это плохая практика. Правильнее будет запомнить, что если функция декорирована — это не отменить.
* Декораторы оборачивают функции, что может затруднить отладку.

Последняя проблема частично решена добавлением в модуле `functools` функции `functools.wraps`, копирующей всю информацию об оборачиваемой функции (её имя, из какого она модуля, её документацию и т.п.) в функцию-обёртку.

```python
def foo():
    print("foo")

print(foo.__name__)

# Однако, декораторы мешают нормальному ходу дел:
def bar(func):
    def wrapper():
        print("bar")
        return func()
    return wrapper

@bar
def foo():
    print("foo")

print(foo.__name__)

import functools  # "functools" может нам с этим помочь
def bar(func):
    # Объявляем "wrapper" оборачивающим "func" и запускаем магию:
    @functools.wraps(func)
    def wrapper():
        print("bar")
        return func()
    return wrapper

@bar
def foo():
    print("foo")

print(foo.__name__)
```

### Примеры использования декораторов

Декораторы могут быть использованы для расширения возможностей функций из сторонних библиотек (код которых мы не можем изменять), или для упрощения отладки (мы не хотим изменять код, который ещё не устоялся).

Также полезно использовать декораторы для расширения различных функций одним и тем же кодом, без повторного его переписывания каждый раз, например:

```python
def benchmark(func):
    """
    Декоратор, выводящий время, которое заняло
    выполнение декорируемой функции.
    """
    import time
    def wrapper(*args, **kwargs):
        t = time.clock()
        res = func(*args, **kwargs)
        print(func.__name__, time.clock() - t)
        return res
    return wrapper

def logging(func):
    """
    Декоратор, логирующий работу кода.
    (хорошо, он просто выводит вызовы, но тут могло быть и логирование!)
    """
    def wrapper(*args, **kwargs):
        res = func(*args, **kwargs)
        print(func.__name__, args, kwargs)
        return res
    return wrapper

def counter(func):
    """
    Декоратор, считающий и выводящий количество вызовов
    декорируемой функции.
    """
    def wrapper(*args, **kwargs):
        wrapper.count += 1
        res = func(*args, **kwargs)
        print("{0} была вызвана: {1}x".format(func.__name__, wrapper.count))
        return res
    wrapper.count = 0
    return wrapper

@benchmark
@logging
@counter
def reverse_string(string):
    return ''.join(reversed(string))

print(reverse_string("А роза упала на лапу Азора"))

print(reverse_string("A man, a plan, a canoe, pasta, heros, rajahs, a coloratura,"
                     "maps, snipe, percale, macaroni, a gag, a banana bag, a tan, a tag,"
                     "a banana bag again (or a camel), a crepe, pins, Spam, a rut, a Rolo, cash,"
                     "a jar, sore hats, a peon, a canal: Panama!"))
```

* **Декораторы определяют структурные блоки многократного использования, которые можно применять к вызываемому объекту с целью модификации его поведения без необратимого изменения самого вызываемого объекта;**
* **Синтаксис `@` является всего-навсего сокращенной записью для вызова декоратора с входной функцией. Многочисленные декораторы, размещенные над одной-единственной функцией, применяются снизу-вверх (*стековая укладка декораторов*);**
* **В качестве оптимального практического приема отладки используйте в своих собственных декораторах вспомогательный декоратор `functools.wraps`, чтобы переносить метаданные из недекорированного вызываемого объекта в декорированный;**
* **Точно так же, как и любой другой инструмент в комплекте инструментов разработки программного обеспечения, декораторы не являются панацеей, и ими не стоит злоупотреблять. Важно уравновесить необходимость «довести дело до конца» с целевой установкой «не увязнуть в ужасной и неудобной в обслуживании мешанине кодовой базы».**

#### Используемые материалы:
1) [Декораторы - pythonworld.ru](https://pythonworld.ru/osnovy/dekoratory.html)
2) Сила декораторов - Чистый Puthon (Дэн Бейдер)

#### Полезные декораторы

#### Свойства @property

Декоратор `@property` облегчает создание свойств в классах `Python`. Свойства выглядят как обычные атрибуты (поля) класса, но при их чтении вызывается геттер (`getter`), при записи – сеттер (`setter`), а при удалении – делитер (`deleter`). Геттер и делитер опциональны.

Свойства нужны, чтобы элегантно в стиле ООП обрабатывать работу с полями класса. В ООП с полями класса не работают напрямую, они сокрыты. В интерфейс взаимодействия выводятся геттеры и сеттеры. Кроме того, геттер может производить вычисления, если свойство не хранится в классе, а является результатом какой-то математической формулы. А сеттер может проверять входные данные на корректность и вызывать побочные эффекты, например, сеттер при установке позиции картинки на экране может вызвать перерисовку экрана.

Декоратор `@property` возвращает объект-дескриптор. `@property` встроен и виден без `import`.

```python
class Box:
    def __init__(self):
        self.__weight = 0

    @property
    def weight(self):
        return self.__weight

    @weight.setter
    def weight(self, new_weight):
        if new_weight < 0:
            raise ValueError('negative weight')
        self.__weight = new_weight


b = Box()
b.weight = 100
print(b.weight)  # 100
b.weight = -10  # ValueError
```

Вычислимое свойство:

```python
class Circle:
    def __init__(self, r):
        self.r = r

    @property
    def area(self):
        return 3.1415 * self.r**2


c = Circle(10)
print(c.area)
```

#### Статические и классовые методы

Методы могут быть не только у экземпляра класса, но и у самого класса, которые вызываются без какого-то экземпляра (без `self`). Декораторы `@staticmethod` и `@classmethod` как раз делают метод таким (**статическим** или **классовым**). Эти декораторы встроены и видны без `import`.

**Статический метод** – это способ поместить функцию в класс, если она логически относится к этому классу. Статический метод ничего не знает о классе, из которого его вызвали.

```python
class Foo:
    @staticmethod
    def help():
        print('help for Foo class')


Foo.help()
```

**Классовый метод** напротив знает, из какого класса его вызывают. Он принимает неявный первый аргумент (обычно его зовут `cls`), который содержит вызывающий класс. Классовые методы прекрасно подходят, когда нужно учесть иерархию наследования. Пример: метод `group` создает список из нескольких людей. Причем для `Person` – список `Person`, а для `Worker` – список `Worker`. Со `@staticmethod` такое бы не вышло:

```python
class Person:
    @classmethod
    def group(cls, n):
        # cls именно тот класс, который вызвал
        return [cls() for _ in range(n)]

    def __repr__(self):
        return 'Person'


class Worker(Person):
    def __repr__(self):
        return 'Worker'


print(Person.group(3))
# [Person, Person, Person]

print(Worker.group(2))
# [Worker, Worker]
```

#### Кэширование @lru_cache

Запоминает результаты функции для данного набора аргументов, при следующем вызове уже не выполняет функцию, а достает результат из кэша. Размер кэша регулируется. Часто используемые элементы остаются в кэше, редкие – вытесняются, если размер доходит до максимального.

Пример. Без кэша это рекурсивная функция чисел Фибоначчи была бы крайне неэффективна:

```python
import functools

@functools.lru_cache(maxsize=128)
def fibonacci(n):
    if n == 0:
        return 0
    elif n == 1:
        return 1
    return fibonacci(n - 1) + fibonacci(n - 2)
```

#### @functools.wraps

Декоратор `@functools.wraps` полезен при разработке других декораторов. Передает имя, документацию и прочую мета-информацию из декорируемой функции к ее обертке.

Декораторы делают отладку и работу с интерпретатором `Python` неуклюжей и трудоемкой. К счастью, существует быстрое решение этой проблемы: декоратор `functools.wraps`, включенный в стандартную библиотеку `Python`.

Декоратор `functools.wraps` можно использовать в своих собственных декораторах для того, чтобы копировать потерянные метаданные из недекорированной функции в замыкание декоратора:

```python
import functools
def uppercase(func):
    @functools.wraps(func)
    def wrapper():
        return func().upper()
    return wrapper
```

Применение декоратора `functools.wraps` к замыканию-обертке, возвращаемому декоратором переносит в него строку документации и другие метаданные входной функции:

```python
@uppercase def greet():
    """Вернуть дружеское приветствие."""
    return 'Привет!'

>>> greet.__name__
'greet'
>>> greet.__doc__
'Вернуть дружеское приветствие.'
```

В качестве оптимального практического приема я порекомендовал бы использовать декоратор `functools.wraps` во всех декораторах, которые вы пишете сами. Это не займет много времени и уменьшит головную боль вам (и другим) в будущем при отладке.


#### Используемые материалы:
1) [Полезные декораторы - tirinox.ru](https://tirinox.ru/useful-decorators/)
2) Как писать «отлаживаемые» декораторы - Чистый Puthon (Дэн Бейдер)

## Общие структуры данных в Python
### Словари, ассоциативные массивы и хеш-таблицы
В `Python` любой неизменяемый объект (например, **целое число**, **логическое значение**, **строка**, **кортеж**) является **хешируемым**, что означает, что его значение не изменяется в течение его времени существования. Это позволяет `Python` создавать уникальное хеш-значение для его идентификации, которое может использоваться словарями для отслеживания уникальных ключей и наборов для отслеживания уникальных значений.

Словари `Python` индексируются ключами, у которых может быть любой хешируемый тип, хешируемый объект имеет хеш-значение, которое никогда не меняется в течение его жизни, и его можно сравнивать с другими объектами. Кроме того, эквивалентные друг другу хешируемые объекты должны иметь одинаковое хеш-значение.

Помимо «обыкновенных» объектов `dict`, стандартная библиотека `Python` также содержит ряд реализаций специализированных словарей. Все эти специализированные словари опираются на встроенный класс словаря (и обладают его характеристиками производительности), но помимо этого еще добавляют некоторые удобные свойства.

#### collections.OrderedDict
В `Python` включен специализированный подкласс `dict`, который запоминает порядок вставки добавляемых в него ключей: `collections.OrderedDict`.

Между прочим, `OrderedDict` не является встроенной составной частью базового языка и должен быть импортирован из модуля `collections`, находящегося в стандартной библиотеке.

#### collections.defaultdict
Класс `defaultdict` — это еще один подкласс словаря, который в своем конструкторе принимает вызываемый объект, возвращаемое значение которого будет использовано, если требуемый ключ нельзя найти.

#### collections.ChainMap
Структура данных `collections.ChainMap` группирует многочисленные словари в одну таблицу соответствия. Поиск проводится по очереди во всех базовых ассоциативных объектах до тех пор, пока ключ не будет найден. Операции вставки, обновления и удаления затрагивают только первую таблицу соответствия, добавленную в цепочку.

```python
from collections import ChainMap 

dict1 = {'один': 1, 'два': 2} 
dict2 = {'три': 3, 'четыре': 4} 
chain = ChainMap(dict1, dict2) 
```

#### types.MappingProxyType
`MappingProxyType` — это обертка стандартного словаря, которая предоставляет доступ только для чтения данных обернутого словаря.

Например, он может быть полезен, если требуется вернуть словарь, передающий внутреннее состояние из класса или модуля, при этом препятствуя доступу к этому объекту для записи. Использование `MappingProxyType` позволяет вводить эти ограничения без необходимости сначала создавать полную копию словаря.

```python
from types import MappingProxyType 

writable = {'один': 1, 'два': 2} # доступный для обновления 
read_only = MappingProxyType(writable) 

# Этот представитель/прокси с доступом только для чтения: 
read_only['один'] 

# Так нельзя!
read_only['один'] = 23 

# Обновления в оригинале отражаются в прокси: 
writable['один'] = 42
```
### Массивоподобные структуры данных
С точки зрения производительности поиск элемента, содержащегося в массиве, выполняется очень быстро при условии, что указан индекс элемента. Для данного случая надлежащая реализация массива гарантирует постоянное *O(1)* время доступа.

В своей стандартной библиотеке `Python` содержит несколько массивоподобных структур данных, каждая из которых обладает слегка отличающимися характеристиками.
#### list
Cписки `Python` реализованы как **динамические массивы**. Это означает, что список допускает добавление и удаление элементов и автоматически корректирует резервное хранилище, в котором эти элементы содержатся, путем выделения или высвобождения оперативной памяти.

Списки `Python` могут содержать произвольные элементы — в `Python` абсолютно «всё» является объектом, включая и функции. Поэтому вы можете сочетать и комбинировать разные типы данных и хранить их все в одном списке.

#### tuple
В отличие от списков, в `Python` объекты-кортежи не изменяются. Это означает, что элементы не могут динамически добавляться или удаляться — все элементы в кортеже должны быть определены во время создания. Точно так же, как и списки, кортежи могут содержать элементы произвольных типов данных.

#### array.array
Модуль `Python` `array` обеспечивает пространственно-эффективное хранение элементарных типов данных в стиле языка C, таких как байты, 32-разрядные целые числа, числа с плавающей точкой и т. д. Массивы, создаваемые на основе класса `array.array`, могут изменяться и ведут себя аналогично спискам, за исключением одного важного различия — они являются «типизированными массивами», ограниченными единственным типом данных.

```python
import array 

arr = array.array('f', (1.0, 1.5, 2.0, 2.5))

# Массивы могут изменяться: 
arr[1] = 23.0 
del arr[1] 
arr.append(42.0) 

# Массивы — это "типизированные" структуры данных - нельзя так! 
>>> arr[1] = 'привет' 
```
#### str — неизменяемые массивы символов Юникода
Объекты строкового типа `str` используются для хранения текстовых данных в виде неизменяемых последовательностей символов Юникода. В сущности, это означает, что тип `str` представляет собой неизменяемый массив символов. Как это ни странно, но тип `str` также является рекурсивной структурой данных: каждый символ в строке сам является объектом `str` длиной, равной **1**.

Строковые объекты пространственно эффективны, потому что они плотно упакованы и специализируются на одном-единственном типе данных. 
Если вы храните текст в кодировке Юникод, то лучше использовать этот тип данных. Поскольку строки в `Python` не могут изменяться, модификация строкового значения требует создания модифицированной копии. 

Самым близким эквивалентом «изменяющейся последовательности символов» будет список, в котором символы хранятся по отдельности.

#### bytes — неизменяемые массивы одиночных байтов
Объекты `bytes` представляют собой неизменяемые последовательности одиночных байтов. В концептуальном плане они подобны объектам `str` и их также можно представить как 
неизменяемые массивы байтов.

Аналогично строковому типу, тип `bytes` имеет свой собственный литеральный синтаксис, предназначенный для создания объектов, и объекты этого типа пространственно эффективны. Объекты bytes не могут изменяться.

#### bytearray — изменяемые массивы одиночных байтов
Тип `bytearray` представляет собой изменяемую последовательность целых чисел в диапазоне. Они тесно связаны с объектами `bytes`, при этом главное их отличие в том, что объекты `bytearray` можно свободно изменять — вы можете переписывать элементы, удалять существующие элементы или добавлять новые. Объект `bytearray` будет соответствующим  образом расти и сжиматься.

Объекты `bytearray` могут быть преобразованы обратно в неизменяемые объекты `bytes`, но это влечет за собой копирование абсолютно всех хранящихся в них данных — весьма медленная операция, занимающая *O(n)* времени.

### Записи, структуры и объекты переноса данных
* **`dict` — простые объекты данных**
* **`tuple` — неизменяемые группы объектов**
* **Написание собственного класса**
Классы позволяют определять «шаблоны» многократного использования для объектов данных, причем эти шаблоны гарантируют, что каждый объект предоставляет одинаковый набор полей.

Написание собственного класса — отличная возможность, когда в объекты-записи требуется добавить бизнес-логику и поведение с использованием методов. Однако это означает, что такие объекты технически больше не являются простыми объектами данных.

* **`collections.namedtuple`**
Помимо этого, именованные кортежи являются, скажем так, именованными кортежами (`named tuples`). Доступ к каждому хранящемуся в них объекту можно получить по уникальному идентификатору:

```python
from collections import namedtuple

p1 = namedtuple('Point', 'x y z')(1, 2, 3)
p2 = (1, 2, 3) 
```

* **`typing.NamedTuple`**
Он очень похож на `namedtuple`, и егоvглавное отличие состоит в том, что у него есть обновленный синтаксис для пределения новых типов записей:

```python
from typing import NamedTuple

class Car(NamedTuple):
    colour: str
    weight: float

car1 = Car('красный', 3812.4)

# Экземпляры имеют хороший метод repr:
car1 Car(colour='красный', weight = 3812.4)

# Доступ к полям:
car1.weight # 3812.4
```

* **`struct.Struct — сериализованные С-структуры`**
Класс `struct.Struct1` выполняет преобразование между значениями `Python` и структурами `C`, сериализованными в форму объектов `Python``bytes`. Например, он может использоваться для обработки двоичных данных, хранящихся в файлах или поступающих из сетевых соединений.

Структуры `Struct` определяются с использованием форматного строкоподобного мини-языка, который позволяет определять расположение различных типов данных `C`, таких как `char`, `int` и `long`, а также их беззнаковых вариантов.

Сериализованные структуры редко используются для представления объектов данных, предназначенных для обработки исключительно внутри кода `Python`. Они нужны в первую очередь в качестве формата обмена данными, а не как способ их хранения в оперативной памяти, применяемый только программным кодом `Python`.

В некоторых случаях упаковка примитивных данных в структуры позволяет уменьшить объем потребляемой оперативной памяти, чем их хранение в других типах данных. Однако чаще всего такая работа будет довольно продвинутой (и, вероятно, ненужной) оптимизацией:

```python
from struct import Struct 

MyStruct = Struct('i?f') 
data = MyStruct.pack(23, False, 42.0)

# Вы получаете двоичный объект данных (blob): 
data 
>>> b'x17x00x00x00x00x00x00x00x00x00(B' 

# BLOB-объекты можно снова распаковать: 
MyStruct.unpack(data) 
>>> (23, False, 42.0)
```

### Множества и мультимножества
**Множество** представляет собой неупорядоченную коллекцию объектов, которая не допускает повторяющихся элементов. Как правило, множества используются для быстрой проверки принадлежности значения множеству, вставки новых значений в множество, удаления значений из множества и вычисления на множествах операций, таких как объединение или пересечение двух множеств.

Предполагается, что в «надлежащей» реализации множества операции проверки на принадлежность будут выполняться за быстрое *O(1)* время. Операции объединения, пересечения, разности и взятия подмножеств должны в среднем занимать *O(n)* времени. В реализациях множества, включенных в стандартную библиотеку Python, данные характеристики производительности соблюдаются.

```python
vowels = {'a', 'e', 'i', 'o', 'u'} 
squares = {x * x for x in range(10)}
```

Тем не менее следует быть осторожными: для того чтобы создать пустое множество, вам нужно вызвать конструктор `set()`. Использование фигурных скобок `{}` неоднозначно и вместо этого создаст пустой словарь.

#### set
Тип `set` изменяемый и допускает динамическую вставку и удаление элементов. 

#### frozenset — неизменяемые множества
Класс `frozenset` реализует неизменяемую версию множества `set`. Такое множество не может быть изменено после того, как оно было сконструировано. Множества `frozenset` статичны и допускают только операции с запросами в отношении своих элементов (никаких вставок или удалений). Поскольку множества `frozenset` статичны и хешируемы, они могут использоваться в качестве ключей словаря или в качестве элементов другого множества, а это то, что невозможно с обычными (изменяемыми) объектами-множествами `set`.

#### collections.Counter — мультимножества
Класс `collections.Counter` стандартной библиотеки `Python` реализует тип «мультимножество» (или «мешок»), который допускает неоднократное появление элемента в множестве.

В результате вызова функции `len()` возвращается количество уникальных элементов в мультимножестве, тогда как общее количество элементов может быть получено с использованием функции `sum`.

### Стеки
Стек представляет собой коллекцию объектов, которая поддерживает быструю семантику доступа **LIFO** для вставок и удалений. В отличие от списков или множеств, 
стеки, как правило, не допускают произвольного доступа к объектам, которые они содержат.

С точки зрения производительности предполагается, что надлежащая реализация стека будет занимать *O(1)* времени на операции вставки и удаления. 

Стеки находят широкое применение в алгоритмах, например в синтаксическом анализе языка и управлении рабочей памятью времени исполнения («стек вызовов»). Короткий и красивый алгоритм с использованием стека представлен **поиском в глубину (DFS) на древовидной или графовой структуре данных**.

#### list — простые встроенные стеки
На внутреннем уровне списки Python реализованы как динамические массивы, а значит, при добавлении или удалении элементов им время от времени нужно изменять пространство оперативной памяти для хранящихся в них элементов. Список выделяет избыточную резервную память, с тем чтобы не каждая операция вталкивания и выталкивания требовала изменения размера памяти, и, как результат, для этих операций вы получаете амортизируемую временную сложность *O(1)*.

Чтобы получить производительность с амортизируемым временем *O(1)* для вставок и удалений, новые элементы должны добавляться в конец списка методом `append()` и снова удалятся из конца методом `pop()`. Для оптимальной производительности стеки на основе списков `Python` должны расти по направлению к более высоким индексам и сжиматься к более низким.

Добавление и удаление элементов в начале списка намного медленнее и занимает *O(n)* времени, поскольку существующие элементы должны сдвигаться, чтобы создать место для нового элемента. Такого антишаблона производительности следует избегать.

#### collections.deque — быстрые и надежные стеки
Класс `deque` реализует очередь с двусторонним доступом, которая поддерживает добавление и удаление элементов с любого конца за *O(1)* (неамортизируемое) время. Поскольку двусторонние очереди одинаково хорошо поддерживают добавление и удаление элементов с любого конца, они могут служить и в качестве очередей, и в качестве стеков.

### Очереди
**Очередь** представляет собой коллекцию объектов, которая поддерживает быструю семантику доступа **FIFO** для вставок и удалений.

* **`collections.deque` — быстрые и надежные очереди**
* **`multiprocessing.Queue` — очереди совместных заданий**

### Очереди с приоритетом
**Очередь с приоритетом** представляет собой контейнерную структуру данных, которая управляет набором записей с полностью упорядоченными ключами (например, числовым значением веса) с целью обеспечения быстрого доступа к записи с наименьшим или наибольшим ключом в наборе.

Очередь с приоритетом можно представить как видоизмененную очередь: вместо получения следующего элемента по времени вставки она получает элемент с самым высоким приоритетом. Приоритет отдельных элементов определяется примененным к их ключам упорядочением.

Очереди с приоритетом широко используются для решения задач планирования, например предоставления предпочтений задачам с более высокой актуальностью.

* **`list` — поддержание сортируемой очереди вручную**

* **`heapq` — двоичные кучи на основе списка**

Данная реализация двоичной кучи обычно подкрепляется обыкновенным списком, и она поддерживает вставку и извлечение наименьшего элемента за *O(log n)* время.

Этот модуль — хороший выбор для реализации очередей с приоритетом в `Python`. Поскольку двоичная куча `heapq` технически обеспечивает только реализацию `min-heap` (то есть кучи, где значение в любой вершине не больше, чем значения ее потомков), должны быть предприняты дополнительные шаги, которые обеспечат стабильность сортировки и другие функциональные возможности, которые, как правило, ожидают от «практической версии» очереди с приоритетом.

```python
import heapq

q = []
heapq.heappush(q, (2, 'программировать')) 
heapq.heappush(q, (1, 'есть')) 
heapq.heappush(q, (3, 'спать'))

while q:
 next_item = heapq.heappop(q)
 print(next_item)
```

* **`queue.PriorityQueue` — красивые очереди с приоритетом**

#### Используемые материалы:
1) Общие структуры данных Python - Чистый Puthon (Дэн Бейдер)